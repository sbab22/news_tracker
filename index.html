<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mining News + TSX Move</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font-family: Arial, sans-serif; padding: 20px; background: #f9f9f9; }
  h1 { margin-top: 0; }
  #status { font-size: 0.9em; color: #555; margin-bottom: 10px; white-space: pre-wrap; }
  .news-item { padding: 12px 10px; border-bottom: 1px solid #ddd; }
  .news-item a { font-weight: 700; color: #2a4d69; text-decoration: none; }
  .news-item a:hover { text-decoration: underline; }
  .date { font-size: 0.9em; color: #555; margin-top: 2px; }
  .stock { font-size: 0.92em; margin-top: 6px; }
  .stock .ticker { font-weight: 600; }
  .stock.up { color: #0a7a0a; }
  .stock.down { color: #b00020; }
  .muted { color: #777; }
  .error { color: #b00020; }
</style>
</head>
<body>
<h1>Latest Junior Mining News</h1>
<div id="status" class="muted">Starting…</div>
<div id="news">Loading…</div>

<script>
/* ===================== Config ===================== */
const CSV_URL  = 'companies.csv?v=2'; // cache-bust; keep file in same folder
const FEED_URL = 'https://www.juniorminingnetwork.com/index.php?option=com_obrss&task=feed&id=1:press-releases&format=feed&Itemid=688';

// Yahoo endpoints
const YH_CHART = (symbol, p1, p2) =>
  `https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(symbol)}?period1=${p1}&period2=${p2}&interval=1d`;

// Keep proxies ON for cross-origin calls (RSS + Yahoo)
const USE_PROXIES = true;

/* ================ Multi-proxy fetch (for cross-origin) ================ */
function viaCorsproxy(url) { return 'https://corsproxy.io/?' + encodeURIComponent(url); }
function viaAllOrigins(url) { return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url); }
function viaJina(url) {
  const withHttps = url.startsWith('https://') ? url : 'https://' + url.replace(/^https?:\/\//,'');
  return 'https://r.jina.ai/http/' + withHttps.replace(/^https?:\/\//,'');
}
async function fetchWithFallbacks(url, { asText = true } = {}) {
  const attempts = USE_PROXIES ? [viaCorsproxy(url), viaAllOrigins(url), viaJina(url)] : [url, viaCorsproxy(url), viaAllOrigins(url), viaJina(url)];
  let lastErr;
  for (const u of attempts) {
    try {
      logStatus('Trying: ' + u);
      const res = await fetch(u);
      if (!res.ok) throw new Error('HTTP ' + res.status);
      return asText ? await res.text() : await res.arrayBuffer();
    } catch (e) {
      lastErr = e; logStatus('Failed: ' + u + ' — ' + e.message); console.warn('Fetch failed', u, e);
    }
  }
  throw lastErr ?? new Error('All attempts failed');
}
function logStatus(msg, isError = false) {
  const el = document.getElementById('status');
  el.textContent += (el.textContent ? '\n' : '') + msg;
  if (isError) el.classList.add('error');
}

/* ================= Robust CSV loader (matches your header) ================= */
async function loadCsvIndex() {
  const resp = await fetch(CSV_URL, { cache: 'no-store' });
  if (!resp.ok) throw new Error('CSV HTTP ' + resp.status);

  let text = await resp.text();

  // Strip BOM/zero-widths and normalize newlines
  text = text
    .replace(/^\uFEFF/, '')
    .replace(/[\u200B-\u200F\u202A-\u202E\u2060\uFEFF]/g, '')
    .replace(/\r\n?/g, '\n')
    .trim();

  const lines = text.split('\n').filter(l => l.trim().length);
  if (!lines.length) throw new Error('CSV is empty');

  const headerLine = lines.shift();
  const sampleLine = lines[0] || '';

  // Detect common delimiters; your file uses comma
  const detectDelim = (h, s) => {
    const cand = [',', ';', '\t', '|'];
    let best = ',', bestScore = -1;
    for (const d of cand) {
      const score = (h.split(d).length-1) + (s.split(d).length-1);
      if (score > bestScore) { best = d; bestScore = score; }
    }
    return best;
  };
  const DELIM = detectDelim(headerLine, sampleLine);

  // CSV splitter that handles quotes/escaped quotes
  const splitCsv = (line) => {
    const out = [];
    let cur = '', inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i], nx = line[i+1];
      if (ch === '"') {
        if (inQ && nx === '"') { cur += '"'; i++; } else { inQ = !inQ; }
      } else if (ch === DELIM && !inQ) {
        out.push(cur); cur = '';
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out.map(s => s.trim().replace(/^"|"$/g, ''));
  };

  const header = splitCsv(headerLine).map(h => h.toLowerCase().trim());
  const col = {
    symbol:   header.indexOf('symbol'),
    exchange: header.indexOf('exchange'),
    name:     header.indexOf('name'),
    aliases:  header.indexOf('aliases'),
  };
  if (col.symbol < 0 || col.name < 0) {
    throw new Error('CSV missing "symbol" or "name" header (got: ' + header.join(',') + ')');
  }

  const rows = [];
  for (const line of lines) {
    if (!line.trim() || line.trim().startsWith('#')) continue;
    const parts = splitCsv(line);

    const symbol = (parts[col.symbol]   || '').trim();
    const name   = (parts[col.name]     || '').trim();
    if (!symbol || !name) continue;

    const aliasesRaw = (col.aliases >= 0 ? (parts[col.aliases] || '') : '');
    const aliases = aliasesRaw.split('|').map(a => a.trim()).filter(Boolean);

    rows.push({ symbol, name, aliases });
  }

  if (!rows.length) throw new Error('No data rows with symbol+name found.');
  logStatus(`CSV parsed: ${rows.length} rows (delimiter "${DELIM}")`);
  return rows;
}

/* ================= Matching helpers ================= */
function normalizeName(s) {
  return s.toLowerCase()
    .replace(/&/g, ' and ')
    .replace(/[^\w\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}
function tokenize(s) { return new Set(normalizeName(s).split(' ').filter(Boolean)); }
function jaccard(aSet, bSet) {
  const a = new Set(aSet), b = new Set(bSet);
  let inter = 0; for (const x of a) if (b.has(x)) inter++;
  const union = a.size + b.size - inter;
  return union ? inter / union : 0;
}
function guessCompanyFromTitle(title) {
  const breakers = [
    ' announces',' closes',' provides',' reports',' intersects',' drills',' signs',' acquires',' starts',' begins',
    ' receives',' appoints',' options',' enters',' discovers',' updates',' expands',' increases',' completes',' grants',
    ' to ',' for ',' at '
  ];
  const lower = title.toLowerCase();
  let cut = title.length;
  for (const b of breakers) { const i = lower.indexOf(b); if (i > 0) cut = Math.min(cut, i); }
  let cand = title.slice(0, cut).replace(/^The\s+/i, '').replace(/[-–—|:•]+$/g, '').trim();
  if (cand.split(/\s+/).length < 2) cand = title.split(/\s+/).slice(0, 3).join(' ');
  return cand;
}
function extractTickerFromTitle(title) {
  const ex1 = /(?:TSX|TSXV|CSE|NEO)\s*:\s*([A-Z][A-Z0-9\.-]{1,7})/gi;
  let m; const found = [];
  while ((m = ex1.exec(title)) !== null) found.push(m[1]);
  if (found.length) return found[0] + guessSuffixFromExchange(title);

  const ex2 = /\b([A-Z][A-Z0-9\.-]{1,7})\.(TO|V|CN)\b/g;
  while ((m = ex2.exec(title)) !== null) return m[1] + '.' + m[2];

  return null;
}
function guessSuffixFromExchange(title) {
  const t = title.toUpperCase();
  if (t.includes('TSXV')) return '.V';
  if (t.includes('TSX'))  return '.TO';
  if (t.includes('CSE'))  return '.CN';
  if (t.includes('NEO'))  return '.TO';
  return '';
}
function findTickerByCompany(rows, title) {
  const guess = guessCompanyFromTitle(title);
  const normGuess = normalizeName(guess);

  for (const r of rows) {
    if (normalizeName(r.name) === normGuess) return r.symbol;
    for (const al of r.aliases) if (normalizeName(al) === normGuess) return r.symbol;
  }

  const gt = tokenize(guess);
  let best = { sym: null, score: 0 };
  for (const r of rows) {
    const candList = [r.name, ...r.aliases];
    for (const c of candList) {
      const score = jaccard(gt, tokenize(c));
      if (score > best.score) best = { sym: r.symbol, score };
    }
  }
  return best.score >= 0.4 ? best.sym : null;
}

/* ================= Yahoo Finance ================= */
function firstLastValid(closes) {
  if (!closes || !closes.length) return [null, null];
  let a = null, b = null;
  for (let i = 0; i < closes.length; i++) if (closes[i] != null) { a = closes[i]; break; }
  for (let i = closes.length - 1; i >= 0; i--) if (closes[i] != null) { b = closes[i]; break; }
  return [a, b];
}
function pct(a, b) { return (a == null || b == null) ? null : ((b - a) / a) * 100; }
const pause = ms => new Promise(r => setTimeout(r, ms));

async function getPctChangeAroundDate(symbol, isoDate) {
  const ms = Date.parse(isoDate);
  if (Number.isNaN(ms)) return { change: null, periodText: null };
  const day = 24*60*60*1000;
  const p1 = Math.floor((ms - 2*day)/1000);
  const p2 = Math.floor((ms + 2*day)/1000);
  const text = await fetchWithFallbacks(YH_CHART(symbol, p1, p2));
  const j = JSON.parse(text);
  const result = j?.chart?.result?.[0];
  const closes = result?.indicators?.quote?.[0]?.close || [];
  const [before, after] = firstLastValid(closes);
  return { change: pct(before, after), periodText: '±2 trading days' };
}

/* ================= Feed + render ================= */
function parseXmlOrThrow(text) {
  const xml = new DOMParser().parseFromString(text, 'application/xml');
  if (xml.querySelector('parsererror')) {
    const snippet = text.slice(0, 200).replace(/\s+/g, ' ');
    throw new Error('XML parse error. First 200 chars: ' + snippet);
  }
  return xml;
}

async function render() {
  const newsEl = document.getElementById('news');
  try {
    logStatus('Loading company CSV…');
    const rows = await loadCsvIndex();
    logStatus('Company rows: ' + rows.length);

    logStatus('Fetching RSS…');
    const xmlText = await fetchWithFallbacks(FEED_URL);
    logStatus('Parsing XML…');
    const xml = parseXmlOrThrow(xmlText);

    const items = Array.from(xml.querySelectorAll('item'));
    if (!items.length) throw new Error('No <item> elements in feed.');
    newsEl.innerHTML = '';

    const N = Math.min(15, items.length);
    for (let i = 0; i < N; i++) {
      const item = items[i];
      const title = item.querySelector('title')?.textContent?.trim() || 'No Title';
      const link  = item.querySelector('link')?.textContent?.trim() || '#';
      const pubDateStr = item.querySelector('pubDate')?.textContent?.trim()
        || item.querySelector('dc\\:date')?.textContent?.trim()
        || item.querySelector('updated')?.textContent?.trim()
        || item.querySelector('published')?.textContent?.trim()
        || '';
      const iso = pubDateStr ? new Date(pubDateStr).toISOString() : null;
      const nice = iso ? new Date(iso).toLocaleString() : 'No Date';

      const el = document.createElement('div');
      el.className = 'news-item';
      el.innerHTML = `
        <a href="${link}" target="_blank" rel="noopener">${title}</a>
        <div class="date">${nice}</div>
        <div class="stock muted">Finding ticker…</div>
      `;
      newsEl.appendChild(el);

      // 1) Try to read ticker directly from title
      let symbol = extractTickerFromTitle(title);
      // 2) Fallback: exact/fuzzy via CSV
      if (!symbol) symbol = findTickerByCompany(rows, title);

      const stockDiv = el.querySelector('.stock');

      if (!symbol) {
        stockDiv.textContent = 'Ticker not found (title + CSV failed)';
        continue;
      }
      if (!iso) {
        stockDiv.textContent = `Ticker ${symbol}: date missing`;
        stockDiv.classList.remove('muted');
        continue;
      }

      try {
        await pause(250);
        const { change, periodText } = await getPctChangeAroundDate(symbol, iso);
        if (change == null) {
          stockDiv.textContent = `Ticker ${symbol}: no price data`;
          stockDiv.classList.remove('muted');
        } else {
          const cls = change >= 0 ? 'up' : 'down';
          stockDiv.classList.remove('muted');
          stockDiv.classList.add(cls);
          stockDiv.innerHTML = `Ticker <span class="ticker">${symbol}</span> — ${periodText}: ${change.toFixed(2)}%`;
        }
      } catch (e) {
        console.error(e);
        stockDiv.textContent = `Ticker ${symbol}: price lookup failed`;
        stockDiv.classList.remove('muted');
      }
    }
    logStatus('Done.');
  } catch (e) {
    console.error(e);
    logStatus('ERROR: ' + e.message, true);
    newsEl.innerHTML = '<div class="error">Failed to load. See status above.</div>';
  }
}
render();
</script>
</body>
</html>
