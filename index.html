<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mining News (Robust Feed)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font-family: Arial, sans-serif; padding: 20px; background: #f9f9f9; }
  h1 { margin-top: 0; }
  #status { font-size: 0.9em; color: #555; margin-bottom: 10px; white-space: pre-wrap; }
  .news-item { padding: 10px 0; border-bottom: 1px solid #ddd; }
  .news-item a { font-weight: bold; color: #2a4d69; text-decoration: none; }
  .news-item a:hover { text-decoration: underline; }
  .date { font-size: 0.9em; color: #555; margin-top: 2px; }
  .error { color: #b00020; }
  .muted { color: #777; }
</style>
</head>
<body>
<h1>Latest Junior Mining News</h1>
<div id="status" class="muted">Starting…</div>
<div id="news">Loading…</div>

<script>
/* -------------------- Config -------------------- */
const FEED_URL = 'https://www.juniorminingnetwork.com/index.php?option=com_obrss&task=feed&id=1:press-releases&format=feed&Itemid=688';

// Prefer multiple fallbacks for CORS
function viaCorsproxy(url) {
  return 'https://corsproxy.io/?' + encodeURIComponent(url);
}
function viaAllOrigins(url) {
  return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
}
function viaJina(url) {
  const withHttps = url.startsWith('https://') ? url : 'https://' + url.replace(/^https?:\/\//, '');
  // r.jina.ai returns text/plain, which is fine for XML text parsing
  return 'https://r.jina.ai/http/' + withHttps.replace(/^https?:\/\//, '');
}

// Try several URLs in order; return first successful Response
async function fetchWithFallbacks(url, { asText = true } = {}) {
  const attempts = [
    url,                     // direct (rarely allowed for RSS)
    viaCorsproxy(url),
    viaAllOrigins(url),
    viaJina(url),
  ];
  let lastErr;
  for (const u of attempts) {
    try {
      logStatus('Trying: ' + u);
      const res = await fetch(u);
      if (!res.ok) throw new Error('HTTP ' + res.status);
      return asText ? await res.text() : await res.arrayBuffer();
    } catch (e) {
      lastErr = e;
      logStatus('Failed: ' + u + ' — ' + e.message);
      console.error('Fetch failed', u, e);
    }
  }
  throw lastErr ?? new Error('All attempts failed');
}

function logStatus(msg, isError = false) {
  const el = document.getElementById('status');
  el.textContent += (el.textContent ? '\n' : '') + msg;
  if (isError) el.classList.add('error');
}

// Safe XML parse (shows parsererror details if any)
function parseXmlOrThrow(text) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(text, 'application/xml');
  const err = xml.querySelector('parsererror');
  if (err) {
    // Some proxies wrap content; show first 200 chars for debugging
    const snippet = text.slice(0, 200).replace(/\s+/g, ' ');
    throw new Error('XML parse error. First 200 chars: ' + snippet);
  }
  return xml;
}

async function loadFeed() {
  const newsEl = document.getElementById('news');
  try {
    logStatus('Fetching RSS…');
    const xmlText = await fetchWithFallbacks(FEED_URL, { asText: true });
    logStatus('Fetched. Parsing XML…');
    const xml = parseXmlOrThrow(xmlText);

    // RSS 2.0 uses <item>
    const items = Array.from(xml.querySelectorAll('item'));
    if (!items.length) {
      // Some proxies might strip namespaces; try Atom <entry> as a fallback
      const entries = Array.from(xml.querySelectorAll('entry'));
      if (!entries.length) {
        throw new Error('No <item> or <entry> elements found in feed.');
      } else {
        // Atom fallback render (title/updated/link[@href])
        newsEl.innerHTML = '';
        entries.forEach(entry => {
          const title = entry.querySelector('title')?.textContent?.trim() || 'No Title';
          const link = entry.querySelector('link')?.getAttribute('href') || '#';
          const date = entry.querySelector('updated')?.textContent || entry.querySelector('published')?.textContent || '';
          const nice = date ? new Date(date).toLocaleString() : 'No Date';
          const div = document.createElement('div');
          div.className = 'news-item';
          div.innerHTML = `<a href="${link}" target="_blank" rel="noopener">${title}</a><div class="date">${nice}</div>`;
          newsEl.appendChild(div);
        });
        logStatus('Rendered Atom entries.');
        return;
      }
    }

    // Render RSS items
    newsEl.innerHTML = '';
    items.forEach(item => {
      const title = item.querySelector('title')?.textContent?.trim() || 'No Title';
      const link = item.querySelector('link')?.textContent?.trim() || '#';
      const pubDateStr = item.querySelector('pubDate')?.textContent?.trim() || '';
      const nice = pubDateStr ? new Date(pubDateStr).toLocaleString() : 'No Date';

      const div = document.createElement('div');
      div.className = 'news-item';
      div.innerHTML = `<a href="${link}" target="_blank" rel="noopener">${title}</a><div class="date">${nice}</div>`;
      newsEl.appendChild(div);
    });
    logStatus('Rendered RSS items. Count: ' + items.length);
  } catch (e) {
    console.error(e);
    logStatus('ERROR: ' + e.message, true);
    const newsEl = document.getElementById('news');
    newsEl.innerHTML = '<div class="error">Failed to load news. See status above and console for details.</div>';
  }
}

loadFeed();
</script>
</body>
</html>
